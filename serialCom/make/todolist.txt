1. csv数据存储, flag=1 不存储 flag=2,3 存储(完成)

2. py2exe打包python,pyqt5,pyserial成exe(完成)

3. 缺少日志(完成)

4. 程序名称不太好(完成)

5. 去除所有打印(完成)

6. 去除所有的assert,使程序不崩溃(完成)

7. 缺少串口状态信息(完成)

8. nsis打包最终的exe(完成)

9. 缺少icon图标(完成)

10. 添加命令行命令(windows下无)(完成)

11. 缺少桌面快捷方式(完成)

12. csv数据保存数据不要重复保存(完成)

13. 界面记录10组标志位为2或3的数据(完成)

14. 测试主窗口是否可以单根继承(不可以)(完成)

15. 日志文件太多(完成)

16. 日志文件每天产生一个(完成)

17. 数据文件加上日期(完成)

18. 数据文件每天产生一个(完成)

19. 权限设置,根据用户密码登录

20. 添加国际化翻译

21. 编译所有资源文件(ui, qm),通过qrc生成res_rc.

## 2017.07.30新增需求
1. 界面最大化显示,分辨率(1024*768)(完成)

2. 最新数据显示在表格最前面(完成)

3. 使用数据库(完成)

4. 条形码编辑框焦点设定(完成)

5. 一个产品需要拧紧4个螺丝,一个螺丝需要拧紧和确认拧紧两个动作,
因此有两个最大扭力值, 4个螺丝对应8个扭力值,这8个扭力值绑定一个产品和条形码.

6. 当前扭矩和扭矩角数值高亮显示

7. 实时显示一个螺丝的扭力值的曲线图

8. 一个产品绑定一个条形码

9. 数据显示

10. 汇总数据显示


11. 添加扫码功能(注意焦点问题)
一般来说，扫描的条码会出现在鼠标光标闪烁的地方
好像条码最后带一个回车的。
记得之前做的时候是直接把鼠标放入输入框中，也就是让输入框处于激活状态，扫描以后会自动输入的。
条码扫描枪相当于一个键盘, 只不过是自动输入的. 因为条码都是ASCII字符.
把你的输入焦点放到一个编辑框上, 然后扫描一个条码,数据就自动输入到编辑框了, 当然, 如果你不需要编辑框, 也可以拦截WM_CHAR消息.
最数据的最后, 会跟一个回车表示扫描结束.

扫描枪会促发个回车事件
扫描枪输入时也会触发KeyPress事件

条码枪
因为是要使用一维条码枪，所以查资料得知，市面上一维条码枪一般有三种接口类型，USB、keyboard和com接口，其实USB和keyboard接口都是HID设备。
编程实现

条码枪扫描到条码后会自动发送一串字符串，只要写程序接收字符串进行处理即可。假如使用HID接口的条码枪，那么它相当于一个键盘，在Qt程序中只要做一个文本输入框将光标移入，条码枪扫描到信息便会发送一个字符串，并显示在输入框中。若是使用串口（COM）接口的条码枪，则使用Qt编程打开连接的串口进行监听，将条码枪传送的数据进行处理即可。

主要函数：


void keyPressEvent(QKeyEvent *keyValue);
QString barStr;
QString curStr;

void MainWindow::keyPressEvent(QKeyEvent *keyValue)
{
    if(keyValue->key() == Qt::Key_Return){//enter
        curStr = ui->lineEdit->text();
        ui->lineEdit->setText(barStr);
        barStr.clear();
    }else{
        barStr += keyValue->text();
    }
    qDebug() << "enter!";
}


def __init__(self, parent=None):
    QWidget.__init__(self, parent)

    edit = QLineEdit("Select & Focus", self)
    edit.selectAll()
    edit.setFocus()             # works now

    vbox = QVBoxLayout()
    vbox.addWidget(edit)
    self.setLayout(vbox)

看起来条形码扫描器只是模仿键盘输入（或者也许只是这个特定的模型）。无论如何，我目前的解决方案是：当有效的按键事件发生时，定时器启动200毫秒。
如果它在该时间范围内收到剩余的数字，那么它接受输入。否则它重置stt。键盘通常不会在很短的时间内允许许多按键。


